package ac.cn.origind.lrcv2toassjs

import kotlin.js.Date

private val timestampRegex = "\\[(\\d+):(\\d+)\\.(\\d+)]".toRegex()
@JsName("convertLRCV2")
fun convertLRCV2(lrcv2: String, kCmd: String): String {
    val tokens = ArrayList<RawToken>()

    lrcv2.lines().forEach { line ->
        val matches = timestampRegex.findAll(line).toList()
        if (!matches.isEmpty()) {
            if (matches[0].range.start != 0)
                tokens.add(TextToken(line.substring(0, matches[0].range.start)))
            matches.forEachIndexed { idx, it ->
                val values = it.groupValues
                tokens.add(TimeToken(values[1], values[2], values[3]))
                if (it.range.endInclusive < line.length - 1) {
                    val end = if (idx == matches.size - 1) line.length else matches[idx + 1].range.start
                    tokens.add(TextToken(line.substring(it.range.endInclusive + 1, end)))
                }
            }
        }
        tokens += LineSeparatorToken
    }

    tokens.add(0, LineSeparatorToken)

    val processeds = processTokens(tokens)

    val res = buildString {
        append("""
[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None
PlayResX: 1920
PlayResY: 1080

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,70,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
""")

        var lineStartCs = 0
        var lineBuilder = StringBuilder()
        //val fmt = DateTimeFormatter.ofPattern("HH:mm:ss.SSS")

        processeds.forEach {
            when (it) {
                is LineStartToken -> {
                    lineStartCs = it.timeCs
                    lineBuilder = StringBuilder()
                }
                is Syllable -> {
                    lineBuilder.append("{\\")
                    lineBuilder.append(kCmd)
                    lineBuilder.append(it.endCs - it.startCs)
                    lineBuilder.append('}')
                    lineBuilder.append(it.text)
                }
                is LineEndToken -> {
                    val start = Date(lineStartCs * 10)
                    val end = Date(it.timeCs * 10)
                    val s = assFormat(start)
                    val e = assFormat(end)
                    //val s = fmt.format(LocalTime.ofNanoOfDay(lineStartCs * 10000000L)).dropLast(1)
                    //val e = fmt.format(LocalTime.ofNanoOfDay(it.timeCs * 10000000L)).dropLast(1)
                    append("Dialogue: 0,")
                    append(s)
                    append(',')
                    append(e)
                    append(",Default, ,0,0,0, ,")

                    append(lineBuilder.toString())
                    append('\n')
                }
            }
        }
    }
    return res
}

fun assFormat(date: Date): String {
    return buildString {
        append(date.getUTCHours())
        append(':')
        append(date.getUTCMinutes().toString().padStart(2, '0'))
        append(':')
        append(date.getUTCSeconds().toString().padStart(2, '0'))
        append('.')
        append((date.getUTCMilliseconds() / 10).toString().padStart(2, '0'))
    }
}

private fun processTokens(tokens: ArrayList<RawToken>): MutableList<ProcessedToken> {
    val processeds = ArrayList<ProcessedToken>()
    var previousLineEndToken = LineEndToken()
    var previousLineStartToken: LineStartToken
    var previousSyllable = Syllable("")
    var previousToken: ProcessedToken = previousLineEndToken
    var previousTime = 0
    tokens.forEach {
        when (it) {
            LineSeparatorToken -> {
                if (previousToken is Syllable && (previousToken as Syllable).endCs != 0)
                    previousLineEndToken = LineEndToken((previousToken as Syllable).endCs)
                previousLineEndToken = LineEndToken()
                processeds.add(previousLineEndToken)
                previousLineStartToken = LineStartToken()
                previousToken = previousLineStartToken
                processeds.add(previousLineStartToken)
            }
            is TimeToken -> {
                if (previousToken is LineStartToken)
                    (previousToken as LineStartToken).timeCs = it.time

                if (previousLineEndToken.timeCs == 0)
                    previousLineEndToken.timeCs = it.time - 1
                if (previousSyllable.endCs == 0)
                    previousSyllable.endCs = it.time - 1
                previousTime = it.time
            }
            is TextToken -> {
                val syl = Syllable(it.text, previousTime, 0)
                previousToken = syl
                previousSyllable = syl
                processeds += syl
            }

        }
    }
    return processeds
}

interface RawToken
object LineSeparatorToken: RawToken
data class TimeToken(val time: Int): RawToken {
    constructor(str1: String, str2: String, str3: String) : this(
            str1.toInt() * 60 * 100
                    + str2.toInt() * 100
                    + if (str3.length > 2) str3.toInt() / 10 else str3.toInt())
}
data class TextToken(val text: String): RawToken

interface ProcessedToken
data class LineStartToken(var timeCs: Int = 0): ProcessedToken
data class LineEndToken(var timeCs: Int = 0): ProcessedToken
data class Syllable(var text: String, var startCs: Int = 0, var endCs: Int = 0): ProcessedToken

class Line {
    val builder = StringBuilder()
    var startTimeCs = 0
    var endTimeCs = 0
}